class ProposalBloc extends Bloc<ProposalEvent, ProposalState> {
  final ProposalRepository proposalRepository;
  List<ProposalModel> _allProposal = []; // Store original orders for filtering
  bool _hasFetched = false;
  ProposalBloc(this.proposalRepository) : super(ProposalInitial()) {
    on<GetProposalSearchAllEvent>((event, emit) async {
      if (_hasFetched) {
        return;
      }
      emit(ProposalLoadingState());
      try {
        final result = await proposalRepository.fetchProposalBuyUserId();
        debugPrint(result.runtimeType.toString());
        if (result is SuccessResponse) {
          List<ProposalModel> proposals = result.data as List<ProposalModel>;
          _allProposal = proposals;
          _hasFetched = true;
          final activeProposals = proposals
              .where((o) => o.proposalStatus!.trim().toLowerCase() == 'active')
              .toList();


          final reversionCount = proposals
              .where((o) =>
                  o.proposalStatus!.trim().toLowerCase() == 'modification')
              .toList();
          final pausedCount = proposals
              .where((o) => o.proposalStatus!.trim().toLowerCase() == 'pause')
              .toList();
          final cancelledCount = proposals
              .where(
                  (o) => o.proposalStatus!.trim().toLowerCase() == 'cancelled')
              .toList();
          final pendedCount = proposals
              .where((o) => o.proposalStatus!.trim().toLowerCase() == 'pending')
              .toList();

          emit(ProposalLoadedState(
              proposalModel: activeProposals,
              activeCount: activeProposals.length,
              pausedCount: pausedCount.length,
              reversionCount: reversionCount.length,
              pendedCount: pendedCount.length,));
        } else if (result is ErrorResponse) {
          emit(ProposalFailedState(result.message));
        }
      } catch (e) {
        print(e.toString());
        emit(ProposalFailedState(e.toString()));
      }
    });

    on<GetProposalSearchEvent>((event, emit) {
      if (state is ProposalLoadedState) {
        final currentState = state as ProposalLoadedState;

        final filteredProposal = _allProposal
            .where((proposal) =>
                proposal.proposalStatus!.trim().toLowerCase() ==
                event.proposalStatus.trim().toLowerCase())
            .toList();
        emit(ProposalLoadedState(
            proposalModel: filteredProposal,
            activeCount: currentState.activeCount,
            pausedCount: currentState.pausedCount,
            reversionCount: currentState.reversionCount,
            pendedCount: currentState.pendedCount));
      }
    });

    on<GetProposalSearchAllEvent>((event, emit) {
      if (state is ProposalLoadedState) {
        final currentState = state as ProposalLoadedState;

        emit(ProposalLoadedState(
            proposalModel: _allProposal,
            activeCount: currentState.activeCount,
            pausedCount: currentState.pausedCount,
            reversionCount: currentState.reversionCount,
            pendedCount: currentState.pendedCount,));
      }
    });
    on<GetProposalRefreshEvent>((event, emit) {
      _hasFetched = false;
      add(LoadProposalEvent());
    });

    on<PostProposalEvent>((event,emit)async{
emit(LoadingPostProposalState());
    final result = await proposalRepository.postProposal(event.proposalModel);
    if(result is SuccessResponse){
      emit(SuccessPostProposalState(message: 'Proposal created successfully!'));
    }else if(result is ErrorResponse){
      emit(FailedPostProposalState(message: result.message));

    }
    
    });
  }
}